#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#undef NDEBUG
#ifdef __cplusplus
#include <cassert>
#else // __cplusplus
#include <assert.h>
#endif // __cplusplus

#define zarrs_assert(expr) assert(ZARRS_SUCCESS == expr)


#ifdef __cplusplus
namespace  {
#endif // __cplusplus

enum ZarrsResult
#ifdef __cplusplus
  : int32_t
#endif // __cplusplus
 {
  ZARRS_SUCCESS = 0,
  ZARRS_ERROR_NULL_PTR = -1,
  ZARRS_ERROR_STORAGE = -2,
  ZARRS_ERROR_ARRAY = -3,
  ZARRS_ERROR_BUFFER_LENGTH = -4,
  ZARRS_ERROR_INVALID_INDICES = -5,
  ZARRS_ERROR_NODE_PATH = -6,
  ZARRS_ERROR_STORE_PREFIX = -7,
  ZARRS_ERROR_INVALID_METADATA = -8,
  ZARRS_ERROR_STORAGE_CAPABILITY = -9,
};
#ifndef __cplusplus
typedef int32_t ZarrsResult;
#endif // __cplusplus

typedef struct ZarrsArray_T ZarrsArray_T;

typedef struct ZarrsStorage_T ZarrsStorage_T;

/**
 * An opaque handle to a zarr array.
 */
typedef struct ZarrsArray_T *ZarrsArray;

/**
 * An opaque handle to a zarr store or storage transformer.
 */
typedef struct ZarrsStorage_T *ZarrsStorage;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the size of a chunk in bytes.
 *
 * # Safety
 * `array` must be a valid `ZarrsArray` handle.
 */
ZarrsResult zarrsArrayGetChunkSize(ZarrsArray array,
                                   const uint64_t *chunk_indices,
                                   size_t chunk_indices_len,
                                   size_t *chunk_bytes_length);

/**
 * Get the size of a subset in bytes.
 *
 * # Safety
 * `array` must be a valid `ZarrsArray` handle.
 */
ZarrsResult zarrsArrayGetSubsetSize(ZarrsArray array,
                                    const uint64_t *subset_shape,
                                    size_t subset_dimensionality,
                                    size_t *subset_bytes_length);

/**
 * Retrieve a chunk from an array.
 *
 * # Errors
 * Returns an error if the array does not have read capability.
 *
 * # Safety
 * `array` must be a valid `ZarrsArray` handle.
 * `path` and `chunk_indices` must have length `chunk_indices_len`.
 */
ZarrsResult zarrsArrayRetrieveChunk(ZarrsArray array,
                                    const uint64_t *chunk_indices,
                                    size_t chunk_indices_len,
                                    size_t chunk_bytes_length,
                                    uint8_t *chunk_bytes);

/**
 * Retrieve a subset from an array.
 *
 * # Errors
 * Returns an error if the array does not have read capability.
 *
 * # Safety
 * `array` must be a valid `ZarrsArray` handle.
 * `path` and `chunk_indices` must have length `chunk_indices_len`.
 */
ZarrsResult zarrsArrayRetrieveSubset(ZarrsArray array,
                                     const uint64_t *subset_start,
                                     const uint64_t *subset_shape,
                                     size_t subset_dimensionality,
                                     size_t subset_bytes_length,
                                     uint8_t *subset_bytes);

/**
 * Store a chunk.
 *
 * # Errors
 * Returns an error if the array does not have write capability.
 *
 * # Safety
 * `array`  must be a valid `ZarrsArray` handle.
 * `path` and `chunk_indices` must have length `chunk_indices_len`.
 */
ZarrsResult zarrsArrayStoreChunk(ZarrsArray array,
                                 const uint64_t *chunk_indices,
                                 size_t chunk_indices_len,
                                 size_t chunk_bytes_length,
                                 const uint8_t *chunk_bytes);

/**
 * Store array metadata.
 *
 * # Errors
 * Returns an error if the array does not have write capability.
 *
 * # Safety
 * `array` must be a valid `ZarrsArray` handle.
 */
ZarrsResult zarrsArrayStoreMetadata(ZarrsArray array);

/**
 * Store an array subset.
 *
 * # Errors
 * Returns an error if the array does not have read/write capability.
 *
 * # Safety
 * `array`  must be a valid `ZarrsArray` handle.
 * `path` and `chunk_indices` must have length `chunk_indices_len`.
 */
ZarrsResult zarrsArrayStoreSubset(ZarrsArray array,
                                  const uint64_t *subset_start,
                                  const uint64_t *subset_shape,
                                  size_t subset_dimensionality,
                                  size_t subset_bytes_length,
                                  const uint8_t *subset_bytes);

/**
 * Create a handle to an existing array (read/write capability).
 *
 * `pArray` is a pointer to a handle in which the created [`ZarrsArray`] is returned.
 *
 * # Safety
 * `pArray` must be a valid pointer to a [`ZarrsArray`] handle.
 */
ZarrsResult zarrsCreateArrayRW(ZarrsStorage storage, const char* path, ZarrsArray *pArray);

/**
 * Create a handle to a new array (read/write capability).
 *
 * `metadata` is expected to be a JSON string representing a zarr V3 array `zarr.json`.
 *
 * `pArray` is a pointer to a handle in which the created [`ZarrsArray`] is returned.
 *
 * # Safety
 * `pArray` must be a valid pointer to a [`ZarrsArray`] handle.
 */
ZarrsResult zarrsCreateArrayRWWithMetadata(ZarrsStorage storage,
                                           const char* path,
                                           const char* metadata,
                                           ZarrsArray *pArray);

/**
 * Create a storage handle to a filesystem store.
 *
 * `pStorage` is a pointer to a handle in which the created [`ZarrsStorage`] is returned.
 *
 * # Safety
 * `pStorage` must be a valid pointer to a [`ZarrsStorage`] handle.
 */
ZarrsResult zarrsCreateStorageFilesystem(const char* path, ZarrsStorage *pStorage);

/**
 * Destroy array.
 *
 * # Errors
 * Returns `ZarrsResult::ZARRS_ERROR_NULL_PTR` if `array` is a null pointer.
 *
 * # Safety
 * If not null, `array` must be a valid `ZarrsArray` handle.
 */
ZarrsResult zarrsDestroyArray(ZarrsArray array);

/**
 * Destroy storage.
 *
 * # Errors
 * Returns `ZarrsResult::ZARRS_ERROR_NULL_PTR` if `storage` is a null pointer.
 *
 * # Safety
 * If not null, `storage` must be a valid storage device created with a `zarrsStorage` function.
 */
ZarrsResult zarrsDestroyStorage(ZarrsStorage storage);

/**
 * Get the last error string.
 */
const char *zarrsLastError(void);

/**
 * Get the zarrs version.
 *
 * See [zarrs::version::version].
 */
uint32_t zarrsVersion(void);

/**
 * Get the zarrs major version.
 *
 * See [`zarrs::version::version_major`].
 */
uint32_t zarrsVersionMajor(void);

/**
 * Get the zarrs minor version.
 *
 * See [`zarrs::version::version_minor`].
 */
uint32_t zarrsVersionMinor(void);

/**
 * Get the zarrs patch version.
 *
 * See [`zarrs::version::version_patch`].
 */
uint32_t zarrsVersionPatch(void);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#ifdef __cplusplus
} // namespace 
#endif // __cplusplus
